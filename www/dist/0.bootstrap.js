(window["webpackJsonp"] = window["webpackJsonp"] || []).push([[0],{

/***/ "../pkg/wasm_minesweeper.js":
/*!**********************************!*\
  !*** ../pkg/wasm_minesweeper.js ***!
  \**********************************/
/*! exports provided: CellState, CellKind, Cell, Minesweeper, __wbindgen_object_drop_ref, __wbindgen_string_new, __widl_f_log_1_, __wbg_floor_5efa4e3d8e57289e, __wbg_random_09364f2d8647f133, __wbindgen_throw */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"CellState\", function() { return CellState; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"CellKind\", function() { return CellKind; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Cell\", function() { return Cell; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Minesweeper\", function() { return Minesweeper; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"__wbindgen_object_drop_ref\", function() { return __wbindgen_object_drop_ref; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"__wbindgen_string_new\", function() { return __wbindgen_string_new; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"__widl_f_log_1_\", function() { return __widl_f_log_1_; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"__wbg_floor_5efa4e3d8e57289e\", function() { return __wbg_floor_5efa4e3d8e57289e; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"__wbg_random_09364f2d8647f133\", function() { return __wbg_random_09364f2d8647f133; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"__wbindgen_throw\", function() { return __wbindgen_throw; });\n/* harmony import */ var _wasm_minesweeper_bg_wasm__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./wasm_minesweeper_bg.wasm */ \"../pkg/wasm_minesweeper_bg.wasm\");\n\n\nlet cachegetInt32Memory = null;\nfunction getInt32Memory() {\n    if (cachegetInt32Memory === null || cachegetInt32Memory.buffer !== _wasm_minesweeper_bg_wasm__WEBPACK_IMPORTED_MODULE_0__[\"memory\"].buffer) {\n        cachegetInt32Memory = new Int32Array(_wasm_minesweeper_bg_wasm__WEBPACK_IMPORTED_MODULE_0__[\"memory\"].buffer);\n    }\n    return cachegetInt32Memory;\n}\n\nlet cachedTextDecoder = new TextDecoder('utf-8');\n\nlet cachegetUint8Memory = null;\nfunction getUint8Memory() {\n    if (cachegetUint8Memory === null || cachegetUint8Memory.buffer !== _wasm_minesweeper_bg_wasm__WEBPACK_IMPORTED_MODULE_0__[\"memory\"].buffer) {\n        cachegetUint8Memory = new Uint8Array(_wasm_minesweeper_bg_wasm__WEBPACK_IMPORTED_MODULE_0__[\"memory\"].buffer);\n    }\n    return cachegetUint8Memory;\n}\n\nfunction getStringFromWasm(ptr, len) {\n    return cachedTextDecoder.decode(getUint8Memory().subarray(ptr, ptr + len));\n}\n\nconst heap = new Array(32);\n\nheap.fill(undefined);\n\nheap.push(undefined, null, true, false);\n\nfunction getObject(idx) { return heap[idx]; }\n\nlet heap_next = heap.length;\n\nfunction dropObject(idx) {\n    if (idx < 36) return;\n    heap[idx] = heap_next;\n    heap_next = idx;\n}\n\nfunction takeObject(idx) {\n    const ret = getObject(idx);\n    dropObject(idx);\n    return ret;\n}\n\nfunction addHeapObject(obj) {\n    if (heap_next === heap.length) heap.push(heap.length + 1);\n    const idx = heap_next;\n    heap_next = heap[idx];\n\n    heap[idx] = obj;\n    return idx;\n}\n\nfunction notDefined(what) { return () => { throw new Error(`${what} is not defined`); }; }\n/**\n* holds information on the current state of a MineSweeper cell\n* `Revealed` - a user has revealed the cell\n* `Marked` - a user has \\\"marked\\\" a cell with either a Flag or Question Mark\n* `Hidden` - the cell has not yet been revealed by the user\n*/\nconst CellState = Object.freeze({ Revealed:0,Flagged:1,Questioned:2,Hidden:3, });\n/**\n* the \\\"kind\\\" of cell, either the Cell is mined, or it is empty (not mined)\n*/\nconst CellKind = Object.freeze({ Mine:0,Empty:1, });\n/**\n* MineSweeper cell\n* holds the state of a minesweeper cell (square)\n*/\nclass Cell {\n\n    static __wrap(ptr) {\n        const obj = Object.create(Cell.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    free() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        _wasm_minesweeper_bg_wasm__WEBPACK_IMPORTED_MODULE_0__[\"__wbg_cell_free\"](ptr);\n    }\n    /**\n    * create a new empty cell, with CellState::Hidden and adjacent mine count of 0\n    * @param {number} kind\n    * @returns {Cell}\n    */\n    static new(kind) {\n        const ret = _wasm_minesweeper_bg_wasm__WEBPACK_IMPORTED_MODULE_0__[\"cell_new\"](kind);\n        return Cell.__wrap(ret);\n    }\n    /**\n    * return the Cell\\'s marker (either a Flag or Question Mark)\n    * is this cell currently flagged?\n    * @returns {boolean}\n    */\n    is_flagged() {\n        const ret = _wasm_minesweeper_bg_wasm__WEBPACK_IMPORTED_MODULE_0__[\"cell_is_flagged\"](this.ptr);\n        return ret !== 0;\n    }\n    /**\n    * is this cell currently questioned?\n    * @returns {boolean}\n    */\n    is_questioned() {\n        const ret = _wasm_minesweeper_bg_wasm__WEBPACK_IMPORTED_MODULE_0__[\"cell_is_questioned\"](this.ptr);\n        return ret !== 0;\n    }\n    /**\n    * @returns {boolean}\n    */\n    is_revealed() {\n        const ret = _wasm_minesweeper_bg_wasm__WEBPACK_IMPORTED_MODULE_0__[\"cell_is_revealed\"](this.ptr);\n        return ret !== 0;\n    }\n    /**\n    * is the cell mined?\n    * @returns {boolean}\n    */\n    is_mined() {\n        const ret = _wasm_minesweeper_bg_wasm__WEBPACK_IMPORTED_MODULE_0__[\"cell_is_mined\"](this.ptr);\n        return ret !== 0;\n    }\n    /**\n    * set the cell\\'s `CellKind`\n    * @param {number} kind\n    */\n    set_kind(kind) {\n        _wasm_minesweeper_bg_wasm__WEBPACK_IMPORTED_MODULE_0__[\"cell_set_kind\"](this.ptr, kind);\n    }\n    /**\n    * get the cell\\'s `CellKind`\n    * set the cell\\'s `CellState`\n    * @param {number} state\n    */\n    set_state(state) {\n        _wasm_minesweeper_bg_wasm__WEBPACK_IMPORTED_MODULE_0__[\"cell_set_state\"](this.ptr, state);\n    }\n    /**\n    * get the cell\\'s `CellState`\n    * return the cell\\'s adjacent mine count\n    * @returns {number}\n    */\n    adj_mine_count() {\n        const ret = _wasm_minesweeper_bg_wasm__WEBPACK_IMPORTED_MODULE_0__[\"cell_adj_mine_count\"](this.ptr);\n        return ret;\n    }\n    /**\n    * set the cell\\'s adjacent mine count\n    * @param {number} count\n    */\n    set_adj_mine_count(count) {\n        _wasm_minesweeper_bg_wasm__WEBPACK_IMPORTED_MODULE_0__[\"cell_set_adj_mine_count\"](this.ptr, count);\n    }\n    /**\n    * return `true` if the cell is Empty and does not have any adjacent mines, else `false`\n    * @returns {boolean}\n    */\n    is_lone_cell() {\n        const ret = _wasm_minesweeper_bg_wasm__WEBPACK_IMPORTED_MODULE_0__[\"cell_is_lone_cell\"](this.ptr);\n        return ret !== 0;\n    }\n}\n/**\n* MineSweeper Game state\n* This struct contains a 2D grid of minesweeper cells stored as a row-major 1D vector\n*/\nclass Minesweeper {\n\n    static __wrap(ptr) {\n        const obj = Object.create(Minesweeper.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    free() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        _wasm_minesweeper_bg_wasm__WEBPACK_IMPORTED_MODULE_0__[\"__wbg_minesweeper_free\"](ptr);\n    }\n    /**\n    * translates a two-dimensional row, column index into a one-dimensional index\n    * @param {number} row\n    * @param {number} column\n    * @returns {number}\n    */\n    to_1d(row, column) {\n        const ret = _wasm_minesweeper_bg_wasm__WEBPACK_IMPORTED_MODULE_0__[\"minesweeper_to_1d\"](this.ptr, row, column);\n        return ret >>> 0;\n    }\n    /**\n    * returns a raw pointer to this Grid\\'s Vector<Cell>\n    * @returns {number}\n    */\n    cells() {\n        const ret = _wasm_minesweeper_bg_wasm__WEBPACK_IMPORTED_MODULE_0__[\"minesweeper_cells\"](this.ptr);\n        return ret;\n    }\n    /**\n    * returns the Cell\\'s of the Grid as a string\n    * @returns {string}\n    */\n    render() {\n        const retptr = 8;\n        const ret = _wasm_minesweeper_bg_wasm__WEBPACK_IMPORTED_MODULE_0__[\"minesweeper_render\"](retptr, this.ptr);\n        const memi32 = getInt32Memory();\n        const v0 = getStringFromWasm(memi32[retptr / 4 + 0], memi32[retptr / 4 + 1]).slice();\n        _wasm_minesweeper_bg_wasm__WEBPACK_IMPORTED_MODULE_0__[\"__wbindgen_free\"](memi32[retptr / 4 + 0], memi32[retptr / 4 + 1] * 1);\n        return v0;\n    }\n    /**\n    * returns the size of a Cell struct\n    * @returns {number}\n    */\n    static cell_size() {\n        const ret = _wasm_minesweeper_bg_wasm__WEBPACK_IMPORTED_MODULE_0__[\"minesweeper_cell_size\"]();\n        return ret >>> 0;\n    }\n    /**\n    * convenience function for logging the state of the grid to the Javascript console\n    * @returns {string}\n    */\n    debug() {\n        const retptr = 8;\n        const ret = _wasm_minesweeper_bg_wasm__WEBPACK_IMPORTED_MODULE_0__[\"minesweeper_debug\"](retptr, this.ptr);\n        const memi32 = getInt32Memory();\n        const v0 = getStringFromWasm(memi32[retptr / 4 + 0], memi32[retptr / 4 + 1]).slice();\n        _wasm_minesweeper_bg_wasm__WEBPACK_IMPORTED_MODULE_0__[\"__wbindgen_free\"](memi32[retptr / 4 + 0], memi32[retptr / 4 + 1] * 1);\n        return v0;\n    }\n    /**\n    * ////////////////////////////////////////////////////////////////////////////////////////\n    * MineSweeperGame Trait Impl\n    * initialize a new MineSweeper grid with the specified rows and columns\n    * This function will generate random mine locations and compute the adjacent mine counts\n    * for every cell in the grid\n    * @param {number} num_rows\n    * @param {number} num_cols\n    * @returns {Minesweeper}\n    */\n    static init(num_rows, num_cols) {\n        const ret = _wasm_minesweeper_bg_wasm__WEBPACK_IMPORTED_MODULE_0__[\"minesweeper_init\"](num_rows, num_cols);\n        return Minesweeper.__wrap(ret);\n    }\n    /**\n    * compute the total number of mines that that a grid should contain based on the number\n    * of rows and columns\n    * Total mines on a grid is 15% * the number of cells i.e.:\n    *     `TOTAL_MINES = grid.num_rows * grid.mum_columns * 0.15`\n    * @returns {number}\n    */\n    total_mines() {\n        const ret = _wasm_minesweeper_bg_wasm__WEBPACK_IMPORTED_MODULE_0__[\"minesweeper_total_mines\"](this.ptr);\n        return ret >>> 0;\n    }\n    /**\n    * computes the remaining number of flags that can be placed by the player\n    * # Returns\n    * a count of the number of remaining flags\n    * @returns {number}\n    */\n    remaining_flags() {\n        const ret = _wasm_minesweeper_bg_wasm__WEBPACK_IMPORTED_MODULE_0__[\"minesweeper_remaining_flags\"](this.ptr);\n        return ret >>> 0;\n    }\n    /**\n    * reveals a cell at the specified index\n    * This function marks the cell\\'s internal state as `CellState::Revealed` and then triggers\n    * the revealing of any \\\"lone\\\" cells that are \\\"connected\\\", or adjacent to, this cell\n    * @param {number} index\n    */\n    reveal_cell(index) {\n        _wasm_minesweeper_bg_wasm__WEBPACK_IMPORTED_MODULE_0__[\"minesweeper_reveal_cell\"](this.ptr, index);\n    }\n    /**\n    * sets the cell\\'s state to flagged if it is currently Hidden, else sets the cell\\'s state\n    * to hidden if it is currently flagged\n    * @param {number} index\n    */\n    toggle_flag(index) {\n        _wasm_minesweeper_bg_wasm__WEBPACK_IMPORTED_MODULE_0__[\"minesweeper_toggle_flag\"](this.ptr, index);\n    }\n    /**\n    * sets the cell\\'s state to questioned if it is currently Hidden, else sets the cell\\'s state\n    * to hidden if it is currently questioned\n    * @param {number} index\n    */\n    toggle_question(index) {\n        _wasm_minesweeper_bg_wasm__WEBPACK_IMPORTED_MODULE_0__[\"minesweeper_toggle_question\"](this.ptr, index);\n    }\n    /**\n    * sets a cell\\'s state to `CellState::Flagged` if the cell is not already revealed\n    * @param {number} index\n    */\n    flag_cell(index) {\n        _wasm_minesweeper_bg_wasm__WEBPACK_IMPORTED_MODULE_0__[\"minesweeper_flag_cell\"](this.ptr, index);\n    }\n    /**\n    * sets a cell\\'s state to `CellState::Questioned` if the cell is not already revealed\n    * @param {number} index\n    */\n    question_cell(index) {\n        _wasm_minesweeper_bg_wasm__WEBPACK_IMPORTED_MODULE_0__[\"minesweeper_question_cell\"](this.ptr, index);\n    }\n    /**\n    * sets a cell\\'s state back to Hiddem if the cell is not already revealed\n    * @param {number} index\n    */\n    unmark_cell(index) {\n        _wasm_minesweeper_bg_wasm__WEBPACK_IMPORTED_MODULE_0__[\"minesweeper_unmark_cell\"](this.ptr, index);\n    }\n    /**\n    * returns true if a cell is flagged AND contains a mine, else false\n    * @param {number} index\n    * @returns {boolean}\n    */\n    flagged_mine_cell(index) {\n        const ret = _wasm_minesweeper_bg_wasm__WEBPACK_IMPORTED_MODULE_0__[\"minesweeper_flagged_mine_cell\"](this.ptr, index);\n        return ret !== 0;\n    }\n    /**\n    * does the cell at `index` contain a mine AND is it currently un-flagged\n    * # Return\n    * `true` if a cell is NOT flagged AND the cell contains a mine, else `false`\n    * @param {number} index\n    * @returns {boolean}\n    */\n    unflagged_mine_cell(index) {\n        const ret = _wasm_minesweeper_bg_wasm__WEBPACK_IMPORTED_MODULE_0__[\"minesweeper_unflagged_mine_cell\"](this.ptr, index);\n        return ret !== 0;\n    }\n    /**\n    * determines if a game of minesweeper has been won.\n    * A game is won if all mined cells have been correctly flagged\n    * # Returns\n    * `true` if the game is won, `false` if the game is not yet won\n    * @returns {boolean}\n    */\n    is_game_won() {\n        const ret = _wasm_minesweeper_bg_wasm__WEBPACK_IMPORTED_MODULE_0__[\"minesweeper_is_game_won\"](this.ptr);\n        return ret !== 0;\n    }\n    /**\n    * determines if a game of minesweeper is lost.\n    * A game is lost if a mined cell was revealed OR once the last flagged was placed but at\n    * least one of the mined cells was left un-flagged\n    * # Returns\n    * `true` if the game is lost, else `false`\n    * @returns {boolean}\n    */\n    is_game_lost() {\n        const ret = _wasm_minesweeper_bg_wasm__WEBPACK_IMPORTED_MODULE_0__[\"minesweeper_is_game_lost\"](this.ptr);\n        return ret !== 0;\n    }\n}\n\nconst __wbindgen_object_drop_ref = function(arg0) {\n    takeObject(arg0);\n};\n\nconst __wbindgen_string_new = function(arg0, arg1) {\n    const ret = getStringFromWasm(arg0, arg1);\n    return addHeapObject(ret);\n};\n\nconst __widl_f_log_1_ = function(arg0) {\n    console.log(getObject(arg0));\n};\n\nconst __wbg_floor_5efa4e3d8e57289e = typeof Math.floor == 'function' ? Math.floor : notDefined('Math.floor');\n\nconst __wbg_random_09364f2d8647f133 = typeof Math.random == 'function' ? Math.random : notDefined('Math.random');\n\nconst __wbindgen_throw = function(arg0, arg1) {\n    throw new Error(getStringFromWasm(arg0, arg1));\n};\n\n\n\n//# sourceURL=webpack:///../pkg/wasm_minesweeper.js?");

/***/ }),

/***/ "../pkg/wasm_minesweeper_bg.wasm":
/*!***************************************!*\
  !*** ../pkg/wasm_minesweeper_bg.wasm ***!
  \***************************************/
/*! exports provided: memory, __wbg_minesweeper_free, minesweeper_to_1d, minesweeper_cells, minesweeper_render, minesweeper_cell_size, minesweeper_debug, minesweeper_init, minesweeper_total_mines, minesweeper_remaining_flags, minesweeper_reveal_cell, minesweeper_toggle_flag, minesweeper_toggle_question, minesweeper_flag_cell, minesweeper_question_cell, minesweeper_unmark_cell, minesweeper_flagged_mine_cell, minesweeper_unflagged_mine_cell, minesweeper_is_game_won, minesweeper_is_game_lost, __wbg_cell_free, cell_new, cell_is_flagged, cell_is_questioned, cell_is_revealed, cell_is_mined, cell_set_kind, cell_set_state, cell_adj_mine_count, cell_set_adj_mine_count, cell_is_lone_cell, __wbindgen_free */
/***/ (function(module, exports, __webpack_require__) {

eval("\"use strict\";\n// Instantiate WebAssembly module\nvar wasmExports = __webpack_require__.w[module.i];\n__webpack_require__.r(exports);\n// export exports from WebAssembly module\nfor(var name in wasmExports) if(name != \"__webpack_init__\") exports[name] = wasmExports[name];\n// exec imports from WebAssembly module (for esm order)\n/* harmony import */ var m0 = __webpack_require__(/*! ./wasm_minesweeper.js */ \"../pkg/wasm_minesweeper.js\");\n\n\n// exec wasm module\nwasmExports[\"__webpack_init__\"]()\n\n//# sourceURL=webpack:///../pkg/wasm_minesweeper_bg.wasm?");

/***/ }),

/***/ "./index.js":
/*!******************!*\
  !*** ./index.js ***!
  \******************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _minesweeper_state__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./minesweeper-state */ \"./minesweeper-state.js\");\n/**\n * These functions render the minesweeper game onto a 2D canvas and handle event processing\n */\n\n\n\nconst CELL_SIZE         = 25;                   // size of a minesweeper cell in the canvas, in px\nconst BORDER_WIDTH      = 2;                    // border width of a cell in px\nconst GRID_COLOR        = \"#CCCCCC\";            // background color of the grid\nconst CELL_BG_COLOR     = \"#C0C0C0\";            // cell background color\nconst CELL_BG_GREEN     = \"#01c00d\";            // cell green background for correctly marked cell\nconst CELL_BG_RED       = \"#fc000c\";            // cell red background for mis-marked cell\nconst CELL_TL_COLOR     = \"#FFFFFF\";            // cell top and left \"highlight\" color to make a 3d effect\nconst CELL_BR_COLOR     = \"#7B7B7B\";            // cell bottom and right \"shaded\" color ro make a 3d effect\n\nconst CELL_FONT_STYLE   = 'bold 12px serif';\nconst TRIANGLE_FLAG     = '\\uD83D\\uDEA9';       // Triangle Flag used to mark a cell\nconst MINE              = '\\uD83D\\uDCA3';       // using a utf-8 bomb for a mine\nconst QUESTION          = '?';                  // represents a questioned cell\nconst SMILEY_OPEN       = '\\uD83D\\uDE03';       // smiley face with open smile\nconst SMILEY_FROWN      = '\\uD83D\\uDE1E';       // smiley face frowning\nconst SMILEY_SHADES     = '\\uD83D\\uDE0E';       // smiley face with sunglasses on\n\nlet num_rows            = 8;                    // default number of rows in the minesweeper grid\nlet num_cols            = 8;                    // default number of columns in the minesweeper grid\n\n// UI elements used on the minesweeper HTML page\nlet canvas = document.getElementById(\"grid-canvas\");\nconst gameBtn = document.getElementById(\"game-btn\");\nconst mineCounter = document.getElementById(\"mine-counter\");\nconst settingsBtn = document.getElementById(\"settings-btn\");\nconst rowSlider = document.getElementById(\"row-slider\");\nconst colSlider = document.getElementById(\"col-slider\");\nconst rowOutput = document.getElementById(\"row-slider-output\");\nconst colOutput = document.getElementById(\"col-slider-output\");\nconst resultHeader = document.getElementById(\"result-header\");\nlet timer;\nlet elapsedTime = 0;\n\n// main object that holds the MinesweeperState\nlet minesweeper;\n\n\n\n// click listener for the 'smiley' face button\ngameBtn.addEventListener('click', () => { newGame() });\n\n// input listeners for the row,col sliders\nrowSlider.addEventListener('input', sliderInputListener);\ncolSlider.addEventListener('input', sliderInputListener);\n\n/**\n * listens for click events on the settings button and toggles the display of the row, column sliders on the page\n */\nsettingsBtn.addEventListener(\"click\", () => {\n    const sliders = document.getElementById(\"settings-sliders\");\n    if (sliders.style.display === \"none\") {\n        sliders.style.display = \"flex\";\n        sliders.style.flexDirection = \"column\";\n    } else {\n        sliders.style.display = \"none\"\n    }\n});\n\n/**\n * listener for input events on the row AND col range sliders. This function will trigger the changing of the number\n * of rows and columns in the minesweeper grid and then start a new game\n * @param event - slider (range) input event\n */\nfunction sliderInputListener(event) {\n    if (event.target.id === 'row-slider') {\n        rowOutput.innerText = event.target.value;\n        num_rows = event.target.valueAsNumber;\n    }\n    if (event.target.id === 'col-slider') {\n        colOutput.innerText = event.target.value;\n        num_cols = event.target.valueAsNumber;\n    }\n    newGame();\n}\n\n/**\n * translate the click event's page-relative coordinates into canvas-relative coordinates, and then into a row and\n * column index\n */\nfunction translateClickPosition(event) {\n    const canvas = document.getElementById(\"grid-canvas\");\n    const boundingRect = canvas.getBoundingClientRect();\n\n    const scaleX = canvas.width / boundingRect.width;\n    const scaleY = canvas.height / boundingRect.height;\n\n    const canvasLeft = (event.clientX - boundingRect.left) * scaleX;\n    const canvasTop = (event.clientY - boundingRect.top) * scaleY;\n\n    const row = Math.min(Math.floor(canvasTop / (CELL_SIZE + 1)), num_rows - 1);\n    const col = Math.min(Math.floor(canvasLeft / (CELL_SIZE + 1)), num_cols - 1);\n    return [row,col];\n}\n\n\n/**\n * listen for click events on the canvas grid and perform game logic accordingly. This function is the main\n * game loop\n * @param event - click event on the canvas\n */\nfunction gridClickListener(event) {\n    const ctx = canvas.getContext('2d');\n\n    let [row, col] = translateClickPosition(event);\n\n    console.log(\"clicked [\",row ,\"][\",col, \"]\");\n\n    // start the timer once a grid cell is clicked (if it hasn't been started already)\n    if (!timer) setTimer();\n\n    if (event.ctrlKey) {\n        // mark a cell with a question mark\n        minesweeper.toggleQuestion(row, col);\n    } else if (event.shiftKey) {\n        // flag a cell\n        minesweeper.toggleFlag(row, col);\n    } else {\n        // cell was left clicked, reveal the cell\n        minesweeper.revealCell(row, col);\n    }\n\n    // check if game is won or lost\n    if (minesweeper.isGameWon()) {\n        renderGameWon(ctx);\n    } else if (minesweeper.isGameLost()) {\n        renderGameLost(ctx);\n    } else {\n        // game is not over, so render the grid state\n        renderGrid(ctx);\n        mineCounter.innerText = minesweeper.remainingFlags().toString(10).padStart(3, \"0\");\n    }\n\n}\n\n/**\n * starts the \"seconds elapsed\" timer which is displayed in the upper right section of the grid\n */\nfunction setTimer () {\n    timer = setInterval(function(){\n        elapsedTime += 1;\n        document.getElementById('timer').innerText = elapsedTime.toString().padStart(3, '0');\n    }, 1000);\n}\n\n/**\n * starts a new game of minesweeper, resets all UI elements\n * @returns {Minesweeper} - a struct from Rust/WASM that encapsulates the current game state\n */\nfunction newGame() {\n    // set the row,col lengths from values in the sliders\n    num_rows = rowSlider.valueAsNumber;\n    num_cols = colSlider.valueAsNumber;\n\n    // initialize canvas\n    canvas.style.backgroundColor = CELL_BG_COLOR;\n    canvas.height = (CELL_SIZE + 1) * num_rows + 1;\n    canvas.width = (CELL_SIZE + 1) * num_cols + 1;\n\n    // initialize a new MineSweeper Game\n    minesweeper = new _minesweeper_state__WEBPACK_IMPORTED_MODULE_0__[\"MinesweeperState\"](num_rows, num_cols);\n\n    // reset the result text\n    resultHeader.innerText = \" \";\n    // rest smiley button\n    gameBtn.innerText = SMILEY_OPEN;\n    // reset the timer\n    clearInterval(timer);\n    timer = undefined;\n    elapsedTime = 0;\n    document.getElementById('timer').innerText = elapsedTime.toString().padStart(3, '0');\n    // reset the flags remaining counter\n    mineCounter.innerText = minesweeper.totalMines().toString(10).padStart(3, \"0\");\n\n    // draw the minesweeper grid\n    renderGrid( canvas.getContext('2d') );\n    canvas.addEventListener(\"click\", gridClickListener);\n    return minesweeper;\n}\n\n/**\n * renders the minesweeper game grid on the 2D canvas\n * @param ctx - the canvas context to render to\n */\nfunction renderGrid(ctx) {\n    drawGridLines(ctx);\n    drawGridCells(ctx, minesweeper.cells );\n}\n\n/**\n * reveals and renders all cells of the minsweeper grid. Highlights which cells were flagged correctly and which were\n * flagged incorrectly\n * @param ctx - the canvas context to draw to\n */\nfunction revealEntireGrid(ctx) {\n    drawGridLines(ctx);\n    for (let r=0; r < num_rows; r++) {\n        for (let c=0; c < num_cols; c++) {\n            if (minesweeper.isFlaggedAndMinedCell(r, c)) {\n                drawRevealedCell(ctx, r, c, CELL_BG_GREEN);\n            }\n            if (minesweeper.isUnflaggedAndMinedCell(r, c)) {\n                drawRevealedCell(ctx, r, c, CELL_BG_RED);\n            }\n            minesweeper.revealCell(r, c);\n        }\n    }\n}\n\n/**\n * triggers the game won state by revealing the entire game grid and updating UI components with \"You Won\" message\n * @param ctx - canvas context containing the game grid\n */\nfunction renderGameWon(ctx) {\n    resultHeader.innerText = \"You Won!\";\n    gameBtn.innerText = SMILEY_SHADES;\n    clearInterval(timer);\n    revealEntireGrid(ctx);\n    canvas.removeEventListener(\"click\", gridClickListener);\n}\n\n/**\n * triggers the game lost state by revealing the entire game grid and updating UI components with \"You Lost\" message\n * @param ctx - canvas context containing the game grid\n */\nfunction renderGameLost(ctx) {\n    resultHeader.innerText = \"You Lost!\";\n    gameBtn.innerText = SMILEY_FROWN;\n    clearInterval(timer);\n    revealEntireGrid(ctx);\n    canvas.removeEventListener(\"click\", gridClickListener);\n}\n\n\n/**\n * draw the horizontal and vertical grid lines that separate cells on the canvas\n * @param ctx - canvas context to draw to\n */\nconst drawGridLines = (ctx) => {\n    ctx.beginPath();\n    ctx.strokeStyle = GRID_COLOR;\n    ctx.lineWidth = 2;\n\n    // Vertical lines.\n    for (let i = 0; i <= num_rows; i++) {\n        ctx.moveTo(i * (CELL_SIZE + 1) + 1, 0);\n        ctx.lineTo(i * (CELL_SIZE + 1) + 1, (CELL_SIZE + 1) * num_cols + 1);\n    }\n\n    // Horizontal lines.\n    for (let j = 0; j <= num_cols; j++) {\n        ctx.moveTo(0,                           j * (CELL_SIZE + 1) + 1);\n        ctx.lineTo((CELL_SIZE + 1) * num_rows + 1, j * (CELL_SIZE + 1) + 1);\n    }\n\n    ctx.stroke();\n};\n\n\n/**\n * draws all grid cells on the canvas, taking into account the cell's current state\n * @param ctx - canvas context to render to\n * @param cells - Uint8array of cell data that was returned from Rust/Wasm vector of <Cell>\n */\nfunction drawGridCells(ctx, cells) {\n\n    for (let r = 0; r < num_rows; r++) {\n        for (let c = 0; c < num_cols; c++) {\n            if ( minesweeper.isHiddenCell(r, c) ) {\n                drawHiddenCell(ctx, r, c);\n            } else if (minesweeper.isFlaggedCell(r, c)) {\n                drawHiddenCell(ctx, r, c);  // clear the cell before drawing the flag\n                drawText(ctx, r, c, TRIANGLE_FLAG);\n            } else if (minesweeper.isQuestionedCell(r, c)) {\n                drawHiddenCell(ctx, r, c);  // clear the cell before drawing the question mark\n                ctx.fillStyle = 'black';\n                drawText(ctx, r, c, QUESTION);\n            } else {\n                drawRevealedCell(ctx, r, c, CELL_BG_COLOR);\n            }\n        }\n    }\n}\n\n\n/**\n * draws a hidden cell with a 3D \"shading\" effect on the canvas, at row,col index\n * @param ctx - the canvas context to draw to\n * @param row - row index of the cell\n * @param col - column index of the cell\n */\nfunction drawHiddenCell(ctx, row, col) {\n    // compute the x/y coordinate offset for drawing at the correct position in the grid\n    const x = col * CELL_SIZE + col + 2;\n    const y = row * CELL_SIZE + row + 2;\n\n    const cell = new Path2D();\n    cell.rect(x, y, CELL_SIZE, CELL_SIZE);\n    ctx.fillStyle = CELL_BG_COLOR;\n    ctx.fill(cell);\n    // draw the top border of the cell\n    ctx.beginPath();\n    ctx.moveTo(x, y);\n    ctx.lineTo(x + BORDER_WIDTH, y + BORDER_WIDTH);\n    ctx.lineTo( x + CELL_SIZE - BORDER_WIDTH, y + BORDER_WIDTH);\n    ctx.lineTo( x + CELL_SIZE, y);\n    ctx.fillStyle = CELL_TL_COLOR;\n    ctx.fill();\n    // draw the left border of the cell\n    ctx.beginPath();\n    ctx.moveTo(x, y);\n    ctx.lineTo(x + BORDER_WIDTH, y + BORDER_WIDTH);\n    ctx.lineTo( x + BORDER_WIDTH, y + CELL_SIZE - BORDER_WIDTH);\n    ctx.lineTo( x, y + CELL_SIZE);\n    ctx.fillStyle = CELL_TL_COLOR;\n    ctx.fill();\n    // draw the right border of the cell\n    ctx.beginPath();\n    ctx.moveTo(x + CELL_SIZE, y);\n    ctx.lineTo( x + CELL_SIZE - BORDER_WIDTH, y + BORDER_WIDTH);\n    ctx.lineTo(x + CELL_SIZE - BORDER_WIDTH, y + CELL_SIZE - BORDER_WIDTH);\n    ctx.lineTo(x + CELL_SIZE, y + CELL_SIZE);\n    ctx.fillStyle = CELL_BR_COLOR;\n    ctx.fill();\n    // draw the bottom border of the cell\n    ctx.beginPath();\n    ctx.moveTo(x + CELL_SIZE, y + CELL_SIZE);\n    ctx.lineTo( x + CELL_SIZE - BORDER_WIDTH, y + CELL_SIZE - BORDER_WIDTH);\n    ctx.lineTo(x + BORDER_WIDTH, y + CELL_SIZE - BORDER_WIDTH);\n    ctx.lineTo(x, y + CELL_SIZE);\n    ctx.fillStyle = CELL_BR_COLOR;\n    ctx.fill();\n}\n\n\n/**\n * draw a textual character in a grid cell\n * @param ctx - canvas context to draw to\n * @param row - row index of the cell\n * @param col - col index of the cell\n * @param char - character to draw in the cell\n */\nfunction drawText(ctx, row, col, char) {\n    // compute the x/y coordinate offset for drawing at the correct cell in the grid\n    const x = col * CELL_SIZE + col;\n    const y = row * CELL_SIZE + row;\n\n    ctx.font = CELL_FONT_STYLE;\n    // these next two offsets are used to center the text within a cell\n    const xOffset = Math.floor(CELL_SIZE * 0.40);\n    const yOffset = Math.floor(CELL_SIZE * 0.80);\n    ctx.fillText(char, x + xOffset, y + yOffset);\n}\n\n\n/**\n * draw a \"revealed\" cell on the canvas. A revealed cell, is a cell that has been clicked on by the player\n * @param ctx - canvas context to draw to\n * @param row - row index of the revealed cell\n * @param col - col index of the revealed cell\n * @param bgColor - background color to use for drawing the cell\n */\nfunction drawRevealedCell(ctx, row, col, bgColor = CELL_BG_COLOR) {\n    const x = col * CELL_SIZE + col + 2;    // x origin\n    const y = row * CELL_SIZE + row + 2;    // y origin\n\n    const cell = new Path2D();\n    cell.rect(x, y, CELL_SIZE, CELL_SIZE);\n    ctx.fillStyle = bgColor;\n    ctx.fill(cell);\n\n    // if a cell contains a mine, then draw the mine character in the cell, else draw the adjacent mine count\n    if ( minesweeper.isMinedCell(row, col) ) {\n        drawText(ctx, row, col, MINE);\n    } else {\n        const adjMineCount = minesweeper.cellAdjMineCount(row, col);\n        ctx.fillStyle = getTextColor(adjMineCount);\n        drawText(ctx, row, col, adjMineCount);\n    }\n}\n\n\n/**\n * compute the color that will be used to display a cell's adjacent mine count\n * @param adjMineCount - adjacent mine count of a cell, must be between 0 and 8\n * @returns a color string\n */\nfunction getTextColor(adjMineCount) {\n    const colors = [\n        '',\n        '#0000FA',\n        '#4B802D',\n        '#DB1300',\n        '#202081',\n        '#690400',\n        '#457A7A',\n        '#1B1B1B',\n        '#7A7A7A',\n    ];\n    return colors[adjMineCount];\n}\n\n/**\n * initialize the row,col sliders UI elements\n */\nfunction initializeSliders() {\n    rowSlider.value = num_rows;\n    colSlider.value = num_cols;\n    rowOutput.innerText = num_rows;\n    colOutput.innerText = num_cols;\n    document.getElementById(\"settings-sliders\").style.display = \"none\";\n}\n\ninitializeSliders();\nnewGame();\n\n\n//# sourceURL=webpack:///./index.js?");

/***/ }),

/***/ "./minesweeper-state.js":
/*!******************************!*\
  !*** ./minesweeper-state.js ***!
  \******************************/
/*! exports provided: MinesweeperState */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MinesweeperState\", function() { return MinesweeperState; });\n/* harmony import */ var wasm_minesweeper__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! wasm-minesweeper */ \"../pkg/wasm_minesweeper.js\");\n/* harmony import */ var wasm_minesweeper_wasm_minesweeper_bg__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! wasm-minesweeper/wasm_minesweeper_bg */ \"../pkg/wasm_minesweeper_bg.wasm\");\n\n\n\n/**\n * A wrapper class that contains the current state of the MineSweeper game.\n * This class wraps calls to the Rust side of minesweeper, and is used to interact and make moves on the\n * minesweeper grid.\n * It also contains a \"cells array\" of Uint8 cells, where the state of each cell is held in a group of 3 bytes:\n *      the first bytes is the CellState (Hidden, Revealed, Flagged, Questioned)\n *      the second byte is the CellKind (Mined or Empty)\n *      the third byte is the adjacent mine count (i.e. the total number of mines around the cell)\n */\nclass MinesweeperState {\n\n    constructor(rows, cols) {\n        this.num_rows = rows;\n        this.num_cols = cols;\n        // \"minesweeper\" is the handle to the Rust minesweeper struct\n        this.minesweeper = wasm_minesweeper__WEBPACK_IMPORTED_MODULE_0__[\"Minesweeper\"].init(rows, cols);\n        // the size of the minesweeper Cell struct in bytes\n        this.cellSizeBytes = wasm_minesweeper__WEBPACK_IMPORTED_MODULE_0__[\"Minesweeper\"].cell_size();\n        this.cellsArray = new Uint8Array(wasm_minesweeper_wasm_minesweeper_bg__WEBPACK_IMPORTED_MODULE_1__[\"memory\"].buffer, this.minesweeper.cells(), this.num_rows * this.num_cols * this.cellSizeBytes );\n        // log the locations of mines\n        console.log(this.minesweeper.debug());\n    }\n\n    /**\n     * converts a 2D row,column index into a 1D index.\n     * @param row - row index of cell\n     * @param col - column index of cell\n     * @returns integer - index that can be used to index into the minesweeper cell grid\n     */\n    to_1d(row, col) {\n        return row * this.num_cols + col;\n    };\n\n    /**\n     * returns the size of the Rust Cell struct is bytes.\n     * @returns {number} - the size of a Minesweeper Cell in bytes\n     */\n    get cellBytes() {\n        return this.cellSizeBytes;\n    }\n\n    /**\n     * gets the Cells array that contains the state of every Cell in the minesweeper grid.\n     * Each Cell is this.cellSizeBytes in length (currently 3 bytes). The first byte represents the CellState,\n     * the second byte represents the CellKind and the third byte represents the Adjacent Mine Count\n     * @returns {Uint8Array} of Cell. The total size of the array will be num_rows * num_cols * this.cellSizeBytes\n     */\n    get cells() {\n        return this.cellsArray;\n    }\n\n    /**\n     * toggles the Cell's status from Hidden to Question OR from Questioned to Hidden\n     * @param row - row index of the cell to toggle\n     * @param col - col index of the cell to toggle\n     */\n    toggleQuestion(row, col) {\n        this.minesweeper.toggle_question( this.to_1d(row, col) );\n        this.cellsArray = new Uint8Array(wasm_minesweeper_wasm_minesweeper_bg__WEBPACK_IMPORTED_MODULE_1__[\"memory\"].buffer, this.minesweeper.cells(), this.num_rows * this.num_cols * this.cellSizeBytes )\n    }\n\n    /**\n     * toggles the Cell's status from Flagged to Hidden OR from Hidden to Flagged\n     * @param row - row index of the cell to toggle\n     * @param col - col index of the cell to toggle\n     */\n    toggleFlag(row, col) {\n        this.minesweeper.toggle_flag( this.to_1d(row, col) );\n        this.cellsArray = new Uint8Array(wasm_minesweeper_wasm_minesweeper_bg__WEBPACK_IMPORTED_MODULE_1__[\"memory\"].buffer, this.minesweeper.cells(), this.num_rows * this.num_cols * this.cellSizeBytes )\n    }\n\n    /**\n     * reveals the cell, changing its state to Revealed\n     * @param row - row index of the cell to reveal\n     * @param col - col index of the cell to reveal\n     */\n    revealCell(row, col) {\n        this.minesweeper.reveal_cell( this.to_1d(row, col) );\n        this.cellsArray = new Uint8Array(wasm_minesweeper_wasm_minesweeper_bg__WEBPACK_IMPORTED_MODULE_1__[\"memory\"].buffer, this.minesweeper.cells(), this.num_rows * this.num_cols * this.cellSizeBytes )\n    }\n\n    /**\n     * is the cell currently Flagged and does it contain a mine\n     * @param row - row index of cell to test\n     * @param col - col index of cell to test\n     * @returns {boolean} true if the cell is Flagged and mined\n     */\n    isFlaggedAndMinedCell(row, col) {\n        return this.minesweeper.flagged_mine_cell( this.to_1d(row, col) );\n    }\n\n    /**\n     * is the cell UN-flagged (i.e. either questioned or hidden) and also mined\n     * @param row - row index of cell to check\n     * @param col - col index of cell to check\n     * @returns {boolean} true if cell is unflagged and also mine, else false\n     */\n    isUnflaggedAndMinedCell(row, col) {\n        return this.minesweeper.unflagged_mine_cell( this.to_1d(row, col) );\n    }\n\n    /**\n     * is the cell Hidden (i.e. not revealed)\n     * @param row - row index of cell\n     * @param col - col index of cell\n     * @returns {boolean} true if the cell is Hidden, else false\n     */\n    isHiddenCell(row, col) {\n        return this.cellState(row, col) === wasm_minesweeper__WEBPACK_IMPORTED_MODULE_0__[\"CellState\"].Hidden;\n    }\n\n    /**\n     * is the cell currently Flagged\n     * @param row - row index if cell to check\n     * @param col - col index of cell to check\n     * @returns {boolean} true if cell is currently flagged, else false\n     */\n    isFlaggedCell(row, col) {\n        return this.cellState(row, col) === wasm_minesweeper__WEBPACK_IMPORTED_MODULE_0__[\"CellState\"].Flagged;\n    }\n\n    /**\n     * is the cell currently questioned\n     * @param row - row index of cell to check\n     * @param col - row index of cell to check\n     * @returns {boolean} true if cell is currently questioned, else false\n     */\n    isQuestionedCell(row, col) {\n        return this.cellState(row, col) === wasm_minesweeper__WEBPACK_IMPORTED_MODULE_0__[\"CellState\"].Questioned;\n    }\n\n    /**\n     * does the cell contain a mine\n     * @param row - row index of cell to check\n     * @param col - col index of cell to check\n     * @returns {boolean} true if cell contains a mine, else false\n     */\n    isMinedCell(row, col) {\n        return this.cellKind(row, col) === wasm_minesweeper__WEBPACK_IMPORTED_MODULE_0__[\"CellKind\"].Mine;\n    }\n\n    /**\n     * checks the current game state to see if it is won.\n     * A game is won if all mined cells have been correctly flagged\n     * @returns {boolean} true if the game is won, false if game is not won\n     */\n    isGameWon() {\n        return this.minesweeper.is_game_won();\n    }\n\n    /**\n     * check the current game state to see if a game is lost.\n     * A game is lost if a mined cell is revealed, or if a Empty cell is flagged after all flags have been placed\n     * @returns {boolean} true if the game is lost, false if the game is not (yet) lost\n     */\n    isGameLost() {\n        return this.minesweeper.is_game_lost();\n    }\n\n    /**\n     * how many flags can are left for the player to place on the gird\n     * @returns {number} the number of flags that the player can still place on the grid\n     */\n    remainingFlags() {\n        return this.minesweeper.remaining_flags();\n    }\n\n    /**\n     * the total number of mines on the grid\n     * @returns {number} the total number of mines on the grid.\n     */\n    totalMines() {\n        return this.minesweeper.total_mines();\n    }\n\n\n    /**\n     * gets the CellState information from the cells array. CellState is the first byte within each \"group\" of cell\n     * @param row - row index to lookup within the 'cells' array\n     * @param col - col index to lookup within the 'cells' array\n     * @returns the CellState represented as a Uint8\n     */\n    cellState(row, col) {\n        const cells = this.cells;\n        return cells[ this.to_1d(row, col) * this.cellBytes ];\n    }\n\n    /**\n     * gets the CellKind information from the 'cells' array. CellKind is the second byte of data in each cell \"group\"\n     * @param row - row index to lookup within the 'cells' array\n     * @param col - col index to lookup within the 'cells' array\n     * @returns the CellKind represented as a Uint8\n     */\n    cellKind(row, col) {\n        const cells = this.cells;\n        return cells[ this.to_1d(row, col) * this.cellBytes + 1];\n    }\n\n    /**\n     * gets the adjacent mine count from the 'cells' array. AdjMineCount is the third byte of data in each cell \"group\"\n     * @param row - row index to lookup within the 'cells' array\n     * @param col - col index to lookup within the 'cells' array\n     * @returns the adjMineCount as a Uint8\n     */\n    cellAdjMineCount(row, col) {\n        const cells = this.cells;\n        return cells[ this.to_1d(row, col) * this.cellBytes + 2];\n    }\n}\n\n\n\n//# sourceURL=webpack:///./minesweeper-state.js?");

/***/ })

}]);